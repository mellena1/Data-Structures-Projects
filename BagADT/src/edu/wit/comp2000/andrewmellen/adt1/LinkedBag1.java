package edu.wit.comp2000.andrewmellen.adt1;/**    A class of bags whose entries are stored in a chain of linked nodes.    The bag is never full.    @author Andrew Mellen    @class Data Structures COMP 2000    @assignment Lab 1: Bag ADT    @dueDate 9/19/2016*/public final class LinkedBag1<T> implements BagInterface<T>{	private Node firstNode;       // Reference to first node	private int numberOfEntries;	public LinkedBag1()	{		firstNode = null;      numberOfEntries = 0;	} // end default constructor	public static void main(String args[]){		//Test Constructor		LinkedBag1<String> Bag = new LinkedBag1<>();				//Test add method		System.out.println("---------add----------");		Bag.addHelper("hello");		Bag.addHelper("world");		Bag.addHelper("java");		Bag.addHelper(null);		Bag.addHelper("bag");		Bag.addHelper("ADT");				//Test toArray method		System.out.println("---------toArray----------");		//Array of objects even though its supposed to 		//be an array of T due to type erasure		Object[] bagToArray = Bag.toArray();		for(Object entry : bagToArray){			//Print String value and class type			System.out.println("toArray() Result: " + (String)entry + 					" | Type: " + entry.getClass().getTypeName());		}				//Test isEmpty while Bag is not empty		System.out.println("---------isEmpty (While not empty)----------");		System.out.println("Bag is empty? " + Bag.isEmpty());				//Test getCurrentSize while Bag is not empty		System.out.println("---------getCurrentSize (While not empty)----------");		System.out.println("Size of Bag: " + Bag.getCurrentSize());				//Test remove() while Bag is not empty		System.out.println("---------remove (While not empty)----------");		Bag.remove();		System.out.println(Bag); //Test toString as well				//Test remove(T anEntry) while Bag is not empty		System.out.println("---------remove(T anEntry) (While not empty)----------");		Bag.remove("hello");		System.out.println(Bag);				//Test getFrequencyOf		System.out.println("---------getFrequencyOf----------");		Bag.getFrequencyOfHelper("java"); //Should be 1		Bag.getFrequencyOfHelper("not in here"); //Should be 0				//Test contains		System.out.println("---------contains----------");		Bag.containsHelper("java"); //Should be true		Bag.containsHelper("not in here"); //Should be false				//Test clear		System.out.println("---------clear----------");		Bag.clear();		System.out.println(Bag); //Test toString when Bag is empty				//Test isEmpty while Bag is empty		System.out.println("---------isEmpty (While empty)----------");		System.out.println("Bag is empty? " + Bag.isEmpty());						//Test getCurrentSize while Bag is empty		System.out.println("---------getCurrentSize (While empty)----------");		System.out.println("Size of Bag: " + Bag.getCurrentSize());				//Test remove() while Bag is empty		System.out.println("---------remove (While empty)----------");		Bag.remove();		System.out.println(Bag); //Test toString as well				//Test remove(T anEntry) while Bag is empty		System.out.println("---------remove(T anEntry) (While empty)----------");		Bag.remove("hello");		System.out.println(Bag);	}		//-------------Testing Helper Methods-----------------------	/** Adds a new entry to this bag and returns if it was successful	 * @param newEntry  The object to be added as a new entry.	 * @return  True. */	private void addHelper(T newEntry){		System.out.println("Add " + newEntry + " success? " + add(newEntry));	}		/** Runs getFrequencyOf and prints the result along with the input entry	 * @param anEntry  The entry to be counted.	 * @return  The number of times anEntry appears in the bag. */	private void getFrequencyOfHelper(T anEntry){		System.out.println("Frequency of \"" + anEntry + "\": " + getFrequencyOf(anEntry));	}		/** Runs contains and prints the result along with the input entry	 * @param anEntry  The entry to be searched for.	 * @return  True if anEntry is in the bag, false otherwise. */	private void containsHelper(T anEntry){		System.out.println("Contains \"" + anEntry + "\"?: " + contains(anEntry));	}	//------------End of Testing Helper Methods---------------  		//------------Class Methods-----------------------------	/** Adds a new entry to this bag.	    @param newEntry  The object to be added as a new entry.	    @return  False for a null entry, True otherwise */	public boolean add(T newEntry) // OutOfMemoryError possible	{		//Don't allow null entries		if(newEntry == null){			return false;		}      // Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode;  // Make new node reference rest of chain                                   // (firstNode is null if chain is empty)		firstNode = newNode;       // New node is at beginning of chain		numberOfEntries++;      		return true;	} // end add	/** Retrieves all entries that are in this bag.       @return  A newly allocated array of all the entries in this bag. */	public T[] toArray()	{      // The cast is safe because the new array contains null entries.      @SuppressWarnings("unchecked")      T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast            int index = 0;      Node currentNode = firstNode;      while ((index < numberOfEntries) && (currentNode != null))      {         result[index] = currentNode.data;         index++;         currentNode = currentNode.next;      } // end while            return result;      // Note: The body of this method could consist of one return statement,      // if you call Arrays.copyOf	} // end toArray   	/** Sees whether this bag is empty.       @return  True if the bag is empty, or false if not. */	public boolean isEmpty()	{		return numberOfEntries == 0;	} // end isEmpty   	/** Gets the number of entries currently in this bag.       @return  The integer number of entries currently in the bag. */	public int getCurrentSize()	{		return numberOfEntries;	} // end getCurrentSize   	/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal                was successful, or null. */	public T remove()   {		if(numberOfEntries == 0){ //If no entries, return null			return null;		}		T returnT = firstNode.data; // Get object (of type T) from first node		firstNode = firstNode.next; 	// Change firstNode to the second node 										// in the list		numberOfEntries--;		return returnT;   } // end remove   	/** Removes one occurrence of a given entry from this bag.       @param anEntry  The entry to be removed.       @return  True if the removal was successful, or false otherwise. */   public boolean remove(T anEntry)   {	   Node currentNode = firstNode; // The currentNode in the loop	   Node previousNode = firstNode; // The node right before currentNode	   for(int x = 0; x < numberOfEntries; x++){		   T currentT = currentNode.data; // Data of the currentNode		   //if anEntry is null, you can't use .equals()		   if(currentT.equals(anEntry)){			   previousNode.next = currentNode.next; // Set previousNode's next node 			   										 // pointer to the node after			   										 // currentNode			   numberOfEntries--;			   return true; //anEntry removed		   }		   // Iterate Nodes		   previousNode = currentNode;		   currentNode = currentNode.next;	   }	   return false; //anEntry not found   } // end remove		/** Removes all entries from this bag. */	public void clear()   {      firstNode = null;      numberOfEntries = 0;   } // end clear		/** Counts the number of times a given entry appears in this bag.		 @param anEntry  The entry to be counted.		 @return  The number of times anEntry appears in the bag. */	public int getFrequencyOf(T anEntry)   {		int frequency = 0; //frequency being returned		Node currentNode = firstNode; // The currentNode in the loop		for(int x = 0; x < numberOfEntries; x++){			T currentT = currentNode.data;			//if anEntry is null, you can't use .equals()			if(currentT.equals(anEntry)){				frequency++; //iterate frequency if currentNode.data equals anEntry			}			currentNode = currentNode.next; //iterate node		}		return frequency;   } // end getFrequencyOf		/** Tests whether this bag contains a given entry.		 @param anEntry  The entry to locate.		 @return  True if the bag contains anEntry, or false otherwise. */	public boolean contains(T anEntry)   {		Node currentNode = firstNode; // The currentNode in the loop		for(int x = 0; x < numberOfEntries; x++){			T currentT = currentNode.data;			//if anEntry is null, you can't use .equals()			if((currentT != null) ? currentT.equals(anEntry) : anEntry == null){				return true; //if equals returns true then a match is found, return true			}			currentNode = currentNode.next; //iterate node		}		return false; //didn't find a match, return false   } // end contains		@Override	public String toString(){		String toReturn = "[ ";		Node currentNode = firstNode;		for(int x = 0; x < numberOfEntries; x++){			toReturn = toReturn + currentNode.data + 						((currentNode.next != null) ? ", " : "");			currentNode = currentNode.next;		}		return toReturn + " "				+ "]";	} //ends toString	private class Node	{	  private T    data; // Entry in bag	  private Node next; // Link to next node		private Node(T dataPortion)		{			this(dataPortion, null);			} // end constructor				private Node(T dataPortion, Node nextNode)		{			data = dataPortion;			next = nextNode;			} // end constructor	} // end Node} // end LinkedBag1